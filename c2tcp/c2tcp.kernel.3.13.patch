diff -rupN linux-3.13.org/include/linux/tcp.h linux-3.13/include/linux/tcp.h
--- linux-3.13.org/include/linux/tcp.h	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/include/linux/tcp.h	2017-04-23 12:41:36.294518163 -0400
@@ -320,6 +320,13 @@ struct tcp_sock {
 	 * socket. Used to retransmit SYNACKs etc.
 	 */
 	struct request_sock *fastopen_rsk;
+
+	/* C2TCP Parameters */
+	u32 first_above_time;
+	u32 next_time;
+	u32 cnt_rtt;
+	u16 rec_inv_sqrt;
+
 };
 
 enum tsq_flags {
diff -rupN linux-3.13.org/include/net/tcp.h linux-3.13/include/net/tcp.h
--- linux-3.13.org/include/net/tcp.h	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/include/net/tcp.h	2017-04-23 14:27:36.954448479 -0400
@@ -282,6 +282,17 @@ extern int sysctl_tcp_limit_output_bytes
 extern int sysctl_tcp_challenge_ack_limit;
 extern unsigned int sysctl_tcp_notsent_lowat;
 extern int sysctl_tcp_min_tso_segs;
+/**
+ * System Params:
+ */
+extern int sysctl_tcp_c2tcp_enable;
+extern int sysctl_tcp_c2tcp_interval;
+extern int sysctl_tcp_c2tcp_target;
+extern int sysctl_tcp_c2tcp_alpha;
+extern int sysctl_tcp_c2tcp_x;
+/**
+ * End of
+ */
 
 extern atomic_long_t tcp_memory_allocated;
 extern struct percpu_counter tcp_sockets_allocated;
diff -rupN linux-3.13.org/include/uapi/linux/sysctl.h linux-3.13/include/uapi/linux/sysctl.h
--- linux-3.13.org/include/uapi/linux/sysctl.h	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/include/uapi/linux/sysctl.h	2017-04-23 13:59:27.922466983 -0400
@@ -425,6 +425,13 @@ enum
 	NET_TCP_ALLOWED_CONG_CONTROL=123,
 	NET_TCP_MAX_SSTHRESH=124,
 	NET_TCP_FRTO_RESPONSE=125,
+	/*C2TCP Variables*/
+	NET_TCP_C2TCP_ENABLE=126,
+	NET_TCP_C2TCP_INTERVAL=127,
+	NET_TCP_C2TCP_TARGET=128,
+	NET_TCP_C2TCP_ALPHA=129,
+	NET_TCP_C2TCP_X=130,
+
 };
 
 enum {
diff -rupN linux-3.13.org/kernel/sysctl_binary.c linux-3.13/kernel/sysctl_binary.c
--- linux-3.13.org/kernel/sysctl_binary.c	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/kernel/sysctl_binary.c	2017-04-23 14:05:43.810462865 -0400
@@ -389,6 +389,15 @@ static const struct bin_table bin_net_ip
 	{ CTL_STR,	NET_TCP_CONG_CONTROL,			"tcp_congestion_control" },
 	{ CTL_INT,	NET_TCP_MTU_PROBING,			"tcp_mtu_probing" },
 	{ CTL_INT,	NET_TCP_BASE_MSS,			"tcp_base_mss" },
+
+	/*C2TCP Functionality*/
+	{ CTL_INT,	NET_TCP_C2TCP_ENABLE,			"tcp_c2tcp_enable" },
+	{ CTL_INT,	NET_TCP_C2TCP_INTERVAL,		"tcp_c2tcp_interval" },
+	{ CTL_INT,	NET_TCP_C2TCP_TARGET,			"tcp_c2tcp_target" },
+	{ CTL_INT,	NET_TCP_C2TCP_ALPHA,			"tcp_c2tcp_alpha" },
+	{ CTL_INT,	NET_TCP_C2TCP_X,				"tcp_c2tcp_x" },
+	/*End*/
+
 	{ CTL_INT,	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS,	"tcp_workaround_signed_windows" },
 	{ CTL_INT,	NET_TCP_DMA_COPYBREAK,			"tcp_dma_copybreak" },
 	{ CTL_INT,	NET_TCP_SLOW_START_AFTER_IDLE,		"tcp_slow_start_after_idle" },
diff -rupN linux-3.13.org/net/ipv4/sysctl_net_ipv4.c linux-3.13/net/ipv4/sysctl_net_ipv4.c
--- linux-3.13.org/net/ipv4/sysctl_net_ipv4.c	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/net/ipv4/sysctl_net_ipv4.c	2017-04-23 14:11:49.398458860 -0400
@@ -732,6 +732,48 @@ static struct ctl_table ipv4_table[] = {
 		.extra1		= &zero,
 		.extra2		= &gso_max_segs,
 	},
+	/*
+	 * C2TCP params
+	 */
+	{
+		.procname	= "tcp_c2tcp_enable",
+		.data		= &sysctl_tcp_c2tcp_enable,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
+		.procname	= "tcp_c2tcp_interval",
+		.data		= &sysctl_tcp_c2tcp_interval,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
+		.procname	= "tcp_c2tcp_target",
+		.data		= &sysctl_tcp_c2tcp_target,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
+		.procname	= "tcp_c2tcp_alpha",
+		.data		= &sysctl_tcp_c2tcp_alpha,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
+		.procname	= "tcp_c2tcp_x",
+		.data		= &sysctl_tcp_c2tcp_x,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+
+	/**
+	 * End of
+	 */
 	{
 		.procname	= "udp_mem",
 		.data		= &sysctl_udp_mem,
diff -rupN linux-3.13.org/net/ipv4/tcp_cubic.c linux-3.13/net/ipv4/tcp_cubic.c
--- linux-3.13.org/net/ipv4/tcp_cubic.c	2014-01-19 21:40:07.000000000 -0500
+++ linux-3.13/net/ipv4/tcp_cubic.c	2017-04-23 18:20:52.174295156 -0400
@@ -27,6 +27,9 @@
 #include <linux/module.h>
 #include <linux/math64.h>
 #include <net/tcp.h>
+#include <net/codel.h>
+
+
 
 #define BICTCP_BETA_SCALE    1024	/* Scale factor beta calculation
 					 * max_cwnd = snd_cwnd * beta
@@ -58,6 +61,23 @@ static u32 cube_rtt_scale __read_mostly;
 static u32 beta_scale __read_mostly;
 static u64 cube_factor __read_mostly;
 
+/**
+ * System Params:
+ */
+int sysctl_tcp_c2tcp_enable __read_mostly = 0;
+EXPORT_SYMBOL(sysctl_tcp_c2tcp_enable);
+int sysctl_tcp_c2tcp_interval __read_mostly = 100;
+EXPORT_SYMBOL(sysctl_tcp_c2tcp_interval);
+int sysctl_tcp_c2tcp_target __read_mostly = 100;
+EXPORT_SYMBOL(sysctl_tcp_c2tcp_target);
+int sysctl_tcp_c2tcp_alpha __read_mostly = 0;
+EXPORT_SYMBOL(sysctl_tcp_c2tcp_alpha);
+int sysctl_tcp_c2tcp_x __read_mostly = 1;
+EXPORT_SYMBOL(sysctl_tcp_c2tcp_x);
+/**
+ * End of
+ */
+
 /* Note parameters that are used for precomputing scale factors are read-only */
 module_param(fast_convergence, int, 0644);
 MODULE_PARM_DESC(fast_convergence, "turn on/off fast convergence");
@@ -103,6 +123,37 @@ struct bictcp {
 	u32	curr_rtt;	/* the minimum rtt of current round */
 };
 
+//C2TCP
+static void c2tcp_pkts_acked(struct sock *sk,u32 cnt,s32 rtt_us);
+
+static void Newton_step(struct sock * sk)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	u32 invsqrt = ((u32)tp->rec_inv_sqrt) << REC_INV_SQRT_SHIFT;
+	u32 invsqrt2 = ((u64)invsqrt * invsqrt) >> 32;
+	u64 val = (3LL << 32) - ((u64)tp->cnt_rtt * invsqrt2);
+
+	val >>= 2; /* avoid overflow in following multiply */
+	val = (val * invsqrt) >> (32 - 2 + 1);
+
+	tp->rec_inv_sqrt = val >> REC_INV_SQRT_SHIFT;
+}
+static codel_time_t control_law(codel_time_t t,
+				      codel_time_t interval,
+				      u32 rec_inv_sqrt)
+{
+	return t + reciprocal_divide(interval, rec_inv_sqrt << REC_INV_SQRT_SHIFT);
+}
+
+static void init_c2tcp(struct sock * sk)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	tp->first_above_time=0;
+	tp->cnt_rtt=1;
+	tp->first_above_time=0;
+}
+//End of
+
 static inline void bictcp_reset(struct bictcp *ca)
 {
 	ca->cnt = 0;
@@ -151,6 +202,11 @@ static void bictcp_init(struct sock *sk)
 
 	if (!hystart && initial_ssthresh)
 		tcp_sk(sk)->snd_ssthresh = initial_ssthresh;
+	/**
+	 * C2TCP
+	 */
+	if (sysctl_tcp_c2tcp_enable)
+		init_c2tcp(sk);
 }
 
 /* calculate the cubic root of x using a table lookup followed by one
@@ -432,8 +488,80 @@ static void bictcp_acked(struct sock *sk
 	if (hystart && tp->snd_cwnd <= tp->snd_ssthresh &&
 	    tp->snd_cwnd >= hystart_low_window)
 		hystart_update(sk, delay);
+	/**
+	 * C2TCP Functionality
+	 */
+	if (sysctl_tcp_c2tcp_enable)
+		c2tcp_pkts_acked(sk, cnt, rtt_us);
 }
+/**
+ * C2TCP-Functionality
+ */
+static void c2tcp_pkts_acked(struct sock *sk,u32 cnt,s32 rtt_us)
+{
+	const struct inet_connection_sock *icsk = inet_csk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct bictcp *ca = inet_csk_ca(sk);
+	u32 tmp,tmp2;
+	codel_time_t c2tcp_target=MS2TIME(sysctl_tcp_c2tcp_target);
+	codel_time_t c2tcp_interval=MS2TIME(sysctl_tcp_c2tcp_interval);
+	codel_time_t now=codel_get_time();
+	codel_time_t c2tcp_rtt=MS2TIME(rtt_us/USEC_PER_MSEC);
+	codel_time_t c2tcp_next_time=MS2TIME(tp->next_time/USEC_PER_MSEC);
+
+	if(codel_time_after_eq(c2tcp_target,c2tcp_rtt))
+	{
+		tp->first_above_time=0;
+		tp->cnt_rtt=1;
+		//tp->first_time=0;
+//		bictcp_update(ca, tp->snd_cwnd);
+		tmp2=(rtt_us/USEC_PER_MSEC);
+		if (tmp2==0)
+			tmp2++;
+		tmp=(sysctl_tcp_c2tcp_alpha+sysctl_tcp_c2tcp_target/tmp2);
+		if(tmp==0)
+			tmp++;
+//		tcp_cong_avoid_ai(tp, ca->cnt/tmp);
+		tp->snd_cwnd_cnt+=tmp;
+		if (tp->snd_cwnd_cnt >= tp->snd_cwnd) {
+			if (tp->snd_cwnd < tp->snd_cwnd_clamp)
+				tp->snd_cwnd++;
+			tp->snd_cwnd_cnt = 0;
+		}
+//		else {
+//			tp->snd_cwnd_cnt+=tmp;
+//		}
+
+//		printk(KERN_INFO "c2tcp triggerd! increasing cwnd");
+	}
+	else if (tp->first_above_time==0)
+	{
+		tp->first_above_time=codel_time_to_us((now+c2tcp_interval));
+		tp->next_time=tp->first_above_time;
+		//tp->first_time=1;
+		tp->cnt_rtt=1;
+		tp->rec_inv_sqrt= ~0U >> REC_INV_SQRT_SHIFT;
+		Newton_step(sk);
+	}
+	else if (codel_time_after(now,c2tcp_next_time))
+	{
+		c2tcp_next_time=control_law(now,c2tcp_interval,tp->rec_inv_sqrt);
+
+		tp->next_time=codel_time_to_us(c2tcp_next_time);
+		tp->cnt_rtt++;
+		Newton_step(sk);
+
+		tp->prior_ssthresh = tcp_current_ssthresh(sk);
+		tp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);
+		tp->snd_cwnd	   = 1;
+		tp->snd_cwnd_cnt   = 0;
 
+//		printk(KERN_INFO "c2tcp triggerd! cnt:%d, changing ssthresh from %d to %d\n",tp->cnt_rtt-1,tp->prior_ssthresh,tp->snd_ssthresh);
+	}
+}
+/**
+ * End of ...
+ */
 static struct tcp_congestion_ops cubictcp __read_mostly = {
 	.init		= bictcp_init,
 	.ssthresh	= bictcp_recalc_ssthresh,

